\documentclass[slides]{pgnotes}

\title{Function as a Service}

\begin{document}

\maketitle

\section{Serverless compute}\label{serverless-compute}

Serverless function are the basic PaaS compute component:
\begin{itemize}
\item Sometimes referred to as Function-as-a-Service
\item basic FaaS offering in AWS is called Lambda.
\end{itemize}

\textbf{Recommended reading:}  \href{https://docs.aws.amazon.com/lambda/latest/dg/welcome.html}{AWS lambda developer guide}



\subsection{Key components}\label{key-components}

From the
\href{https://docs.aws.amazon.com/lambda/latest/dg/gettingstarted-concepts.html}{AWS
lambda concepts}:

\begin{description}
\item[Function]
is an AWS resource you can \emph{invoke} to run your own code on AWS
infrastructure.

\begin{itemize}

\item
  Lambda runs your custom code on AWS
\item
  No need for EC2 instances and VPC.
\end{itemize}
\item[Executable]
consists of \textit{code} within a lambda-provided \textit{runtime}:

\begin{description}
\item[Code]
is provided by you, either as source code, bytecode or compiled code.
\item[Runtime]
is provided by AWS. You need to pick the correct runtime for the code
you wish to run.
\end{description}

\item[Event] \textbf{invokes} the lambda function. Might be:
  \begin{itemize}
  \item explicit \texttt{invoke} at the CLI or console, or
  \item event triggered from other AWS services (S3, SNS, API Gateway) including within Lambda itself (SQS polling).
  \end{itemize}
\end{description}

\section{Use cases}





\section{Code}\label{code}

\subsection{Runtime}\label{runtime}

The Runtime refers to the support AWS Lambda offers for different
languages. You can in theory run code in any language that AWS EC2
supports on Lambda. Supports offered for different languages varies:

\begin{itemize}
\item
  \textbf{Python and JavaScript are best supported:}
  \begin{itemize}
  \item You can write / edit functions in the AWS Console.
  \item Most examples online involve these languages.
  \end{itemize}
\item
  A number of other languages are fully supported:
  \begin{itemize}
  \item must be authored / edited locally and uploaded in a \emph{deployment package}.
  \item These include: Java, .net (incl. C\# and PowerShell).
  \end{itemize}
\item
  Code that can run on EC2 using Amazon Linux can be run on Lambda by
  creating a \emph{custom runtime}. This is an involved process but very
  useful for porting legacy code to Lambda.
\end{itemize}

\subsection{Deployment package creation}\label{deployment-package-creation}

Code is bundled into a ZIP file, named a \emph{deployment package}. The
precise layout will depend on the chosen runtime.

\begin{itemize}
\item
  Interpreted languages (like Python, JS) will need the source files.
\item
  Bytecode-compiled languages (like Java) will consist of the
  bytecode-compiled class files.
\end{itemize}

The relevant files can be ZIPped using the \texttt{Compress-Archive} cmdlet in PowerShell.

\section{Execution role}\label{execution-role}

Execution roles are assumed by a lambda function, and grant the function
permissions to use other AWS resources in your account.

Each execution role has a name (e.g. \texttt{helloworld-ex}) from which
we can derive its ARN:

\begin{verbatim}
$ExecutionRoleName="helloworld-ex"
$ExecutionRoleArn="arn:aws:iam::123456789012:role/helloworld-ex"
Write-Host $ExecutionRoleArn
\end{verbatim}

\subsection{Trust policy}\label{sec:trust-policy}

The trust policy specifies what AWS component(s) can assume the role.

\inputminted{json}{trust_policy.json}

\subsection{Attached policies}\label{attached-policies}

Execution roles can then have policies attached using \texttt{iam}.
Rather than write these from scratch, we will attached AWS Managed
Policies. The simplest policy allows a lambda function to write to
CloudWatch Logs:

\inputminted{json}{AWSLambdaBasicExecutionRole.json}

Additional policies can be attached (or created and attached) if the
lambda function needs access to other AWS services.

\section{Hello World example}\label{hello-world-example}

Our simple \texttt{Hello\ World} will just output a message to
CloudWatch logs. It will ignore the input.

The program is a single function, named \texttt{hello\_handler} in a
file named \texttt{hello\_handler.py}. It will run as the execution role
\texttt{hello-ex}.

\subsection{Code}\label{code-1}

We have a python file \texttt{hello\_handler.py} with the following
simple program:

\inputminted{python}{hello_handler.py}

\subsection{Deployment package
creation}\label{deployment-package-creation-1}

To package the code into a ZIP we can:

\begin{verbatim}
Compress-Archive -Path hello_handler.py -DestinationPath hello_code.zip

# issues on Mac/Linux in PowerShell due to file permissions, use instead (in Bash):
zip hello_code.zip hello_handler.py
\end{verbatim}

\subsection{Execution role creation}\label{execution-role-creation}

Our simple trust policy allows Lambda to assume the role (and will work for most functions), defined in \texttt{trust\_policy.json}:

\inputminted{json}{trust_policy.json}

Then we can create the execution role itself:

\begin{verbatim}
# create the role 
aws iam create-role `
--role-name hello-ex `
--assume-role-policy-document file://trust_policy.json

# attach AWSLambdaBasicExecutionRole (for basic I/O needed by Lambda function)
aws iam attach-role-policy `
--role-name helloworld-ex `
--policy-arn arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
\end{verbatim}

\subsection{Function creation}\label{function-creation}

The handler parameter specifies the entry point that handles the event.
Its format varies depending on the runtime (language) used. For python
it normally is:

\begin{verbatim}
[file (without extension)].[function name]
\end{verbatim}

\begin{verbatim}
aws lambda create-function `
--function-name hello `
--zip-file fileb://hello_code.zip `
--handler hello_handler.hello_handler `
--runtime python3.8 `
--role arn:aws:iam::123456789012:role/hello-ex 
\end{verbatim}

\subsection{Invoking the function}\label{invoking-the-function}

We invoke (or run) the function:

\begin{verbatim}
# invoke the function
aws lambda invoke `
--function-name hello `
out.txt

# read output produced
Get-Content hello_out.txt 
\end{verbatim}

\subsection{Updating code}\label{updating-code}

If we want to update the function's code, we can modify the source files
and then:

\begin{verbatim}
# new ZIP file:
Compress-Archive -Force -Path hello_handler.py -DestinationPath hello_code.zip

# update the code on Lambda
aws lambda update-function-code `
--function-name hello `
~--zip-file fileb://hello_code.zip 
\end{verbatim}

\subsection{Deletion}\label{deletion}

\begin{verbatim}
aws lambda delete-function --function-name hello
\end{verbatim}

\section{Input handling}\label{input-handling}

Input is passed in/out of lambda functions using JSON-formatted text.
Python has a built-in dictionary time which the incoming JSON is
transparently converted to. Imagine we modified our hello function to
be:

We expect a firstname and surname input. These are provided as JSON, so
here we make a file for PowerShell to send the lambda function:

Then invoke, this time with the payload given:

\begin{verbatim}
aws lambda invoke --function-name hello `
--payload fileb://payload.json hello_out.txt
\end{verbatim}

\end{document}
